---
layout: post
title:  "VIm"
date:   2017-04-23 10:00:00 +0900
categories: vim editor programming javascript
---

Table of Contents:

* [History](#history)
* [Packages Managers](#packages-managers)
* [NeoVim vs Vim 8](#neovim-vs-vim8)
* [Build a new plugin](#build-a-new-plugin)
* [Current Configuration](#current-config)
* [Debug and maintain a config](#debug-maintain-config)

# [](#history)History

It's been exactly 10 years since I started using [VIm](http://www.vim.org/) as
my main editor. I had started my second internship, and got asked to go through
the VimTutor in order to edit files directly from the servers. I quickly became
passionate about this tool, which had a large community and tons of plugins
behind to allow for any kind of customization.

Looking back since that moment, I sometimes tried other IDE when learning a new
language (e.g scala on IntelliJ, React Native on Atom/Nuclide), but I never
stuck to anything else than VIm.

I also changed VIm configuration more often than I could remember: Changing
computer and wanting a fresher config; Needing a new feature and getting caught
up by all the other new plugins that looked cool; Fighting against a
configuration that became damn slow, etc.

It's interesting to look at the evolution of my vim configs over the time:

* single humongous `.vimrc` file with tons of functions to do it all
* `.vim/` with a bunch of directories for various purposes (autoload, colors,
  ftplugin, etc) and old-style backup.
* Directory versioned with git to better manage files.
* Using git-modules, then git-subtrees, to keep track of plugins changes
  and easily update the local version.
* Using a packages manager: Pathogen, then Vundle, finally Vim-plug

In addition, I sometimes switched back and forth between Vim and gVim/MacVim,
tried do-it-all distributions like
[spf13-vim](https://github.com/spf13/spf13-vim) and
[space-vim](https://github.com/liuchengxu/space-vim), and recently moved to
[NeoVim](https://github.com/neovim/neovim) (still using Vim-plug instead of
NeoBundle).

Therefore, I decided to write this post to introduce my configuration and share
some interesting tips related to Vim

# [](#packages-managers)Packages Managers

**TODO** â†’ Comparatif plugin managers + graph

# [](#neovim-vs-vim8)NeoVim vs Vim 8

Study NeoVim and list differences

# [](#build-a-new-plugin)Build a new plugin

Do some cool and useless application taking advantage of async

# [](#current-config)Current Configuration

# General

## Markdown Stack

```vim
Plug 'junegunn/goyo.vim', { 'for': 'markdown' }
"autocmd! User goyo.vim echom 'Goyo is now loaded!'
let g:goyo_width=80
highlight OverLength ctermbg=red ctermfg=white guibg=#592929
match OverLength /\%81v.\+/
Plug 'junegunn/limelight.vim'
autocmd! User GoyoEnter Limelight
autocmd! User GoyoLeave Limelight!
```

I initially tried to write with `let g:goyo_width=120`, but since the ale plugin
"" will raise warnings if we write more than 80 characters
per line, I reverted to 80 lines and also set **textwidth=80**.
I also noticed that when toggling the i3 full-screen mode, the Goyo view would
unnecessarily scroll below the end of file, only showing the last line to the
screen. In order to force vim to always show at least 20 lines, we can set
**scrolloff=20**

```
autocmd FileType markdown set textwidth=80 scrolloff=20
```

## Python Stack

## Javascript Stack

### [pangloss/vim-javascript](https://www.github.com/pangloss/vim-javascript)

### [mxw/vim-jsx](https://www.github.com/mxw/vim-jsx)

### [leshill/vim-json](https://www.github.com/leshill/vim-json)

# [](#debug-maintain-config)Debug and maintain a config

As time passes, you find a need for new plugins/features and your vim
configuration gets increasingly complex. If you do not carefully evaluate the
resource consumed by your new plugin, it could bloat your system and make it
hopelessly slow.

How could you monitore your plugins? I created a script for that purpose. Here
is how it works:

* start vim for various filetypes, and save verbose output to its dedicated file
* Read the files, and extract all the time points.
* Repeat the operation several types, then average the results (which could
  defer at specific times depending on resources availability.
* Plot all datasets together in a graph, to visualize the time load per
  filetype.
